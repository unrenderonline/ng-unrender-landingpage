<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Mario 64 - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; cursor: none; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js",
                "cannon-es-debugger": "https://cdn.jsdelivr.net/npm/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- Basic Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // --- Physics World Setup ---
        const physicsWorld = new CANNON.World({
            gravity: new CANNON.Vec3(0, -30, 0),
        });

        // --- Third Person Camera ---
        class ThirdPersonCamera {
            constructor(camera, target) {
                this.camera = camera;
                this.target = target;
                this.currentPosition = new THREE.Vector3();
                this.currentLookAt = new THREE.Vector3();
                this.theta = 0;
                this.phi = Math.PI / 4;
                this.distance = 7;

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.body) {
                        this.theta -= e.movementX * 0.002;
                        this.phi = Math.max(0.1, Math.min(Math.PI / 2.2, this.phi - e.movementY * 0.002));
                    }
                });
                document.body.addEventListener('click', () => document.body.requestPointerLock());
            }

            update(delta) {
                if (!this.target) return;
                const idealOffset = new THREE.Vector3(
                    this.distance * Math.sin(this.phi) * Math.sin(this.theta),
                    this.distance * Math.cos(this.phi),
                    this.distance * Math.sin(this.phi) * Math.cos(this.theta)
                );
                idealOffset.add(this.target.position);
                const targetPosition = this.target.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                this.currentPosition.lerp(idealOffset, 10 * delta);
                this.currentLookAt.lerp(targetPosition, 10 * delta);
                this.camera.position.copy(this.currentPosition);
                this.camera.lookAt(this.currentLookAt);
            }
        }
        let thirdPersonCamera;

        // --- Block Character Class ---
        class BlockCharacter {
            constructor() {
                const bodyColor = 0xffb6c1; // light pink
                const handFootColor = 0xf8bbd0; // lighter pink
                const eyeWhite = 0xffffff;
                const eyeBlack = 0x222222;

                this.group = new THREE.Group();

                // Torso
                this.torso = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1.5, 0.6),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                this.torso.position.set(0, 1.5, 0);
                this.group.add(this.torso);

                // Neck
                this.neck = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.22, 0.22, 0.25, 8),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                this.neck.position.set(0, 2.05, 0);
                this.group.add(this.neck);

                // Head
                this.head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.45, 12, 12),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                this.head.position.set(0, 2.5, 0);
                this.group.add(this.head);

                // Ears
                this.leftEar = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                this.leftEar.position.set(-0.38, 2.55, 0);
                this.group.add(this.leftEar);

                this.rightEar = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                this.rightEar.position.set(0.38, 2.55, 0);
                this.group.add(this.rightEar);

                // Eyes
                this.leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.09, 8, 8),
                    new THREE.MeshStandardMaterial({ color: eyeWhite })
                );
                this.leftEye.position.set(-0.13, 2.6, 0.38);
                this.group.add(this.leftEye);

                this.rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.09, 8, 8),
                    new THREE.MeshStandardMaterial({ color: eyeWhite })
                );
                this.rightEye.position.set(0.13, 2.6, 0.38);
                this.group.add(this.rightEye);

                // Pupils
                this.leftPupil = new THREE.Mesh(
                    new THREE.SphereGeometry(0.04, 8, 8),
                    new THREE.MeshStandardMaterial({ color: eyeBlack })
                );
                this.leftPupil.position.set(-0.13, 2.62, 0.44);
                this.group.add(this.leftPupil);

                this.rightPupil = new THREE.Mesh(
                    new THREE.SphereGeometry(0.04, 8, 8),
                    new THREE.MeshStandardMaterial({ color: eyeBlack })
                );
                this.rightPupil.position.set(0.13, 2.62, 0.44);
                this.group.add(this.rightPupil);

                // Mouth (small cube)
                this.mouth = new THREE.Mesh(
                    new THREE.BoxGeometry(0.18, 0.06, 0.02),
                    new THREE.MeshStandardMaterial({ color: eyeBlack })
                );
                this.mouth.position.set(0, 2.48, 0.43);
                this.group.add(this.mouth);

                // Arms
                this.leftArm = new THREE.Group();
                const leftUpperArm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.6, 0.3),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                leftUpperArm.position.set(0, 0.3, 0);
                this.leftArm.add(leftUpperArm);

                const leftLowerArm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.25, 0.5, 0.25),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                leftLowerArm.position.set(0, -0.4, 0);
                this.leftArm.add(leftLowerArm);

                const leftHand = new THREE.Mesh(
                    new THREE.SphereGeometry(0.13, 8, 8),
                    new THREE.MeshStandardMaterial({ color: handFootColor })
                );
                leftHand.position.set(0, -0.7, 0);
                this.leftArm.add(leftHand);

                this.leftArm.position.set(-0.65, 1.7, 0);
                this.group.add(this.leftArm);

                this.rightArm = new THREE.Group();
                const rightUpperArm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.6, 0.3),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                rightUpperArm.position.set(0, 0.3, 0);
                this.rightArm.add(rightUpperArm);

                const rightLowerArm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.25, 0.5, 0.25),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                rightLowerArm.position.set(0, -0.4, 0);
                this.rightArm.add(rightLowerArm);

                const rightHand = new THREE.Mesh(
                    new THREE.SphereGeometry(0.13, 8, 8),
                    new THREE.MeshStandardMaterial({ color: handFootColor })
                );
                rightHand.position.set(0, -0.7, 0);
                this.rightArm.add(rightHand);

                this.rightArm.position.set(0.65, 1.7, 0);
                this.group.add(this.rightArm);

                // Legs
                this.leftLeg = new THREE.Group();
                const leftUpperLeg = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.6, 0.35),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                leftUpperLeg.position.set(0, 0.3, 0);
                this.leftLeg.add(leftUpperLeg);

                const leftLowerLeg = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.4, 0.3),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                leftLowerLeg.position.set(0, -0.25, 0);
                this.leftLeg.add(leftLowerLeg);

                const leftFoot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.22, 0.12, 0.38),
                    new THREE.MeshStandardMaterial({ color: handFootColor })
                );
                leftFoot.position.set(0, -0.45, 0.09);
                this.leftLeg.add(leftFoot);

                this.leftLeg.position.set(-0.25, 0.5, 0);
                this.group.add(this.leftLeg);

                this.rightLeg = new THREE.Group();
                const rightUpperLeg = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.6, 0.35),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                rightUpperLeg.position.set(0, 0.3, 0);
                this.rightLeg.add(rightUpperLeg);

                const rightLowerLeg = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.4, 0.3),
                    new THREE.MeshStandardMaterial({ color: bodyColor })
                );
                rightLowerLeg.position.set(0, -0.25, 0);
                this.rightLeg.add(rightLowerLeg);

                const rightFoot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.22, 0.12, 0.38),
                    new THREE.MeshStandardMaterial({ color: handFootColor })
                );
                rightFoot.position.set(0, -0.45, 0.09);
                this.rightLeg.add(rightFoot);

                this.rightLeg.position.set(0.25, 0.5, 0);
                this.group.add(this.rightLeg);

                scene.add(this.group);

                // Physics Body
                const shape = new CANNON.Box(new CANNON.Vec3(0.5, 1, 0.3));
                this.body = new CANNON.Body({ mass: 5, shape: shape, material: new CANNON.Material(), allowSleep: false });
                this.body.position.set(0, 5, 0);
                physicsWorld.addBody(this.body);

                thirdPersonCamera = new ThirdPersonCamera(camera, this.group);

                this.onGround = false;
                this.keys = { forward: false, backward: false, left: false, right: false, space: false };
                this.jumpTimer = 0;
                this.walkTimer = 0;
                this.initEventListeners();
            }

            initEventListeners() {
                document.addEventListener('keydown', (e) => this.onKey(e.code, true));
                document.addEventListener('keyup', (e) => this.onKey(e.code, false));
                this.body.addEventListener('collide', (e) => {
                    // Check if the collision is with a surface we can stand on
                    const contactNormal = e.contact.ni;
                    if (contactNormal.y > 0.5) {
                        this.onGround = true;
                    }
                });
            }

            onKey(code, isPressed) {
                const keyMap = { 'KeyW': 'forward', 'KeyS': 'backward', 'KeyA': 'left', 'KeyD': 'right', 'Space': 'space' };
                if (keyMap[code]) this.keys[keyMap[code]] = isPressed;
            }

            update(delta) {
                const speed = 6;
                const cameraForward = new THREE.Vector3();
                camera.getWorldDirection(cameraForward);
                cameraForward.y = 0;
                cameraForward.normalize();
                // Fix: swap add/sub for cameraRight
                const cameraRight = new THREE.Vector3().crossVectors(cameraForward, new THREE.Vector3(0, 1, 0));

                let moveDirection = new THREE.Vector3();
                if (this.keys.forward) moveDirection.add(cameraForward);
                if (this.keys.backward) moveDirection.sub(cameraForward);
                if (this.keys.left) moveDirection.sub(cameraRight); // Fix: left is -cameraRight
                if (this.keys.right) moveDirection.add(cameraRight); // Fix: right is +cameraRight

                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                    this.body.velocity.x = moveDirection.x * speed;
                    this.body.velocity.z = moveDirection.z * speed;
                    this.walkTimer += delta * 8;
                } else {
                    // Apply friction
                    this.body.velocity.x *= 0.9;
                    this.body.velocity.z *= 0.9;
                    this.walkTimer = 0;
                }

                // Jump
                if (this.keys.space && this.onGround) {
                    this.body.velocity.y = 12.0;
                    this.onGround = false;
                    this.jumpTimer = 0.5;
                }

                // Animate blocks
                // Walk animation: swing arms/legs
                if (moveDirection.length() > 0 && this.onGround) {
                    const swing = Math.sin(this.walkTimer) * 0.5;
                    this.leftArm.rotation.x = swing;
                    this.rightArm.rotation.x = -swing;
                    this.leftLeg.rotation.x = -swing;
                    this.rightLeg.rotation.x = swing;
                } else {
                    this.leftArm.rotation.x = 0;
                    this.rightArm.rotation.x = 0;
                    this.leftLeg.rotation.x = 0;
                    this.rightLeg.rotation.x = 0;
                }

                // Jump animation: raise arms
                if (!this.onGround && this.jumpTimer > 0) {
                    this.leftArm.rotation.x = -1.2;
                    this.rightArm.rotation.x = -1.2;
                    this.jumpTimer -= delta;
                }

                // Update group position
                this.group.position.copy(this.body.position);

                // Make character always face forward to camera
                // (look in camera's forward direction, ignore y)
                const lookDir = new THREE.Vector3();
                camera.getWorldDirection(lookDir);
                lookDir.y = 0;
                lookDir.normalize();
                const targetQuat = new THREE.Quaternion().setFromUnitVectors(
                    new THREE.Vector3(0, 0, 1), lookDir
                );
                this.group.quaternion.slerp(targetQuat, 0.3);
            }
        }

        // --- Simple Map: Large Ground and Cubes ---
        // Ground
        const groundGeo = new THREE.BoxGeometry(100, 1, 100);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x228822 });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.position.set(0, -0.5, 0);
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        const groundShape = new CANNON.Box(new CANNON.Vec3(50, 0.5, 50));
        const groundBody = new CANNON.Body({ mass: 0, shape: groundShape });
        groundBody.position.set(0, -0.5, 0);
        physicsWorld.addBody(groundBody);

        // Obstacles: a few cubes
        const obstaclePositions = [
            [5, 0.5, 0],
            [10, 1.5, 0],
            [15, 2.5, 0],
            [-5, 0.5, 5],
            [-10, 1.5, -5],
            [0, 0.5, 10]
        ];
        obstaclePositions.forEach((pos, i) => {
            const size = 2;
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(size, size, size),
                new THREE.MeshStandardMaterial({ color: 0x8888ff })
            );
            mesh.position.set(pos[0], pos[1], pos[2]);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(size/2, size/2, size/2));
            const body = new CANNON.Body({ mass: 0, shape: shape });
            body.position.set(pos[0], pos[1], pos[2]);
            physicsWorld.addBody(body);
        });

        // --- Create Player ---
        let player = new BlockCharacter();

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            physicsWorld.step(1 / 60, delta, 3);

            if (player) player.update(delta);
            if (thirdPersonCamera) thirdPersonCamera.update(delta);

            renderer.render(scene, camera);
        }
        animate();

        // --- Handle Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
  

        // --- Handle Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
